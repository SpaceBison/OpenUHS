package net.vhati.openuhs.core;

import java.util.zip.Checksum;


/**
 * An algorithm used for tamper-detection in 9x format UHS files.
 *
 * <p>TODO: There's a conditional fudge in getValue() to make this work.</p>
 *
 * <p>This correctly, if inexplicably, calculates the CRC of every file.
 * Stefan Wolff emailed his Perl algorithm (on 2012-02-21), which frequently
 * worked, but not always. When it disagreed with stored sums (the last two
 * bytes of a file), it was always off by exactly 256.</p>
 *
 * <p>These wrong values occurred when they exceeded the half-way point for an
 * unsigned 16-bit short (32768), when they needed to add 1+FF.</p>
 *
 * <blockquote><pre>
 * {@code
 * if (result >= 0x8000) result = (result + 0x0100) & 0xFFFF;
 * }
 * </pre></blockquote>
 *
 * <p>Perl was likely dealing with a wider numeric type than short, and so,
 * was oblivious to the sign bit, if any.</p>
 *
 * <p>Since the fudge involves addition, the bitwise AND truncates a
 * potential overflowing 17th bit.</p>
 *
 * <p><ul>
 * <li>Illustrative UHS: <i>Star Trek: Borg</i> (low, CRC=32725 aka 0xD5 0x7F)</li>
 * <li>Illustrative UHS: <i>Rent-A-Hero</i> (high, CRC=33060 aka 0x24 0x81)</li>
 * <li>Illustrative UHS: <i>Azrael's Tear</i> (overflow, CRC=113 aka 0x71 0x00)</li>
 * </ul></p>
 */
public class CRC16 implements Checksum {
	private static final int[] a = new int[] {
		0, 32773, 32783, 10, 32795, 30, 20, 32785, 32819, 54,
		60, 32825, 40, 32813, 32807, 34, 32867, 102, 108, 32873,
		120, 32893, 32887, 114, 80, 32853, 32863, 90, 32843, 78,
		68, 32833, 32963, 198, 204, 32969, 216, 32989, 32983, 210,
		240, 33013, 33023, 250, 33003, 238, 228, 32993, 160, 32933,
		32943, 170, 32955, 190, 180, 32945, 32915, 150, 156, 32921,
		136, 32909, 32903, 130, 33155, 390, 396, 33161, 408, 33181,
		33175, 402, 432, 33205, 33215, 442, 33195, 430, 420, 33185,
		480, 33253, 33263, 490, 33275, 510, 500, 33265, 33235, 470,
		476, 33241, 456, 33229, 33223, 450, 320, 33093, 33103, 330,
		33115, 350, 340, 33105, 33139, 374, 380, 33145, 360, 33133,
		33127, 354, 33059, 294, 300, 33065, 312, 33085, 33079, 306,
		272, 33045, 33055, 282, 33035, 270, 260, 33025, 33539, 774,
		780, 33545, 792, 33565, 33559, 786, 816, 33589, 33599, 826,
		33579, 814, 804, 33569, 864, 33637, 33647, 874, 33659, 894,
		884, 33649, 33619, 854, 860, 33625, 840, 33613, 33607, 834,
		960, 33733, 33743, 970, 33755, 990, 980, 33745, 33779, 1014,
		1020, 33785, 1000, 33773, 33767, 994, 33699, 934, 940, 33705,
		952, 33725, 33719, 946, 912, 33685, 33695, 922, 33675, 910,
		900, 33665, 640, 33413, 33423, 650, 33435, 670, 660, 33425,
		33459, 694, 700, 33465, 680, 33453, 33447, 674, 33507, 742,
		748, 33513, 760, 33533, 33527, 754, 720, 33493, 33503, 730,
		33483, 718, 708, 33473, 33347, 582, 588, 33353, 600, 33373,
		33367, 594, 624, 33397, 33407, 634, 33387, 622, 612, 33377,
		544, 33317, 33327, 554, 33339, 574, 564, 33329, 33299, 534,
		540, 33305, 520, 33293, 33287, 514
	};

	private static final int[] b = new int[] {
		0, 33539, 33155, 640, 32963, 960, 320, 33347, 32867, 864,
		480, 33507, 160, 33699, 33059, 544, 32819, 816, 432, 33459,
		240, 33779, 33139, 624, 80, 33619, 33235, 720, 32915, 912,
		272, 33299, 32795, 792, 408, 33435, 216, 33755, 33115, 600,
		120, 33659, 33275, 760, 32955, 952, 312, 33339, 40, 33579,
		33195, 680, 33003, 1000, 360, 33387, 32843, 840, 456, 33483,
		136, 33675, 33035, 520, 32783, 780, 396, 33423, 204, 33743,
		33103, 588, 108, 33647, 33263, 748, 32943, 940, 300, 33327,
		60, 33599, 33215, 700, 33023, 1020, 380, 33407, 32863, 860,
		476, 33503, 156, 33695, 33055, 540, 20, 33559, 33175, 660,
		32983, 980, 340, 33367, 32887, 884, 500, 33527, 180, 33719,
		33079, 564, 32807, 804, 420, 33447, 228, 33767, 33127, 612,
		68, 33607, 33223, 708, 32903, 900, 260, 33287, 32773, 774,
		390, 33413, 198, 33733, 33093, 582, 102, 33637, 33253, 742,
		32933, 934, 294, 33317, 54, 33589, 33205, 694, 33013, 1014,
		374, 33397, 32853, 854, 470, 33493, 150, 33685, 33045, 534,
		30, 33565, 33181, 670, 32989, 990, 350, 33373, 32893, 894,
		510, 33533, 190, 33725, 33085, 574, 32813, 814, 430, 33453,
		238, 33773, 33133, 622, 78, 33613, 33229, 718, 32909, 910,
		270, 33293, 10, 33545, 33161, 650, 32969, 970, 330, 33353,
		32873, 874, 490, 33513, 170, 33705, 33065, 554, 32825, 826,
		442, 33465, 250, 33785, 33145, 634, 90, 33625, 33241, 730,
		32921, 922, 282, 33305, 32785, 786, 402, 33425, 210, 33745,
		33105, 594, 114, 33649, 33265, 754, 32945, 946, 306, 33329,
		34, 33569, 33185, 674, 32993, 994, 354, 33377, 32833, 834,
		450, 33473, 130, 33665, 33025, 514
	};

	private int sum;


	public CRC16() {
		sum = 0x0000;
	}


	@Override
	public long getValue() {
		long result = (((long)sum) & 0xFFFFL);

		if (result >= 0x8000) result = (result + 0x0100) & 0xFFFF;

		return result;
	}

	@Override
	public void reset() {
		sum = 0x0000;
	}

	@Override
	public void update( byte[] b, int off, int len ) {
		for ( int i = off; i < off+len; i++ ) {
			update( (int)b[i] );
		}
	}

	@Override
	public void update( int n ) {
		sum = a[(int) ((sum >> 8) & 0xFF)] ^ ((sum & 0xFF) << 8) ^ b[n & 0xFF];
		sum &= 0xFFFF;
	}
}

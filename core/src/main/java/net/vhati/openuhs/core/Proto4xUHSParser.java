package net.vhati.openuhs.core;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.vhati.openuhs.core.HotSpot;
import net.vhati.openuhs.core.Proto4xUHSParseContext;
import net.vhati.openuhs.core.UHSHotSpotNode;
import net.vhati.openuhs.core.UHSImageNode;
import net.vhati.openuhs.core.UHSNode;
import net.vhati.openuhs.core.UHSParseException;
import net.vhati.openuhs.core.UHSRootNode;


/**
 * A parser for proto4x format UHS files.
 *
 * <p>"*.PUHS" files are generated by the UHS Source Editor v4.</p>
 */
public class Proto4xUHSParser {
	/** Honor the actual UHS file structure for version 9x auxiliary nodes */
	public static final int AUX_NORMAL = 0;

	/** Drop version 9x auxiliary nodes */
	public static final int AUX_IGNORE = 1;

	/** Move version 9x auxiliary nodes to within the master subject node and make that the new root */
	public static final int AUX_NEST = 2;


	private final Logger logger = LoggerFactory.getLogger( Proto4xUHSParser.class );

	private Pattern startPtn = Pattern.compile( "START \\Q***********\\E ([0-9]+)(?: ([Z|A]))?$" );
	private Pattern endPtn = Pattern.compile( "END \\Q***********\\E ([0-9]+)$" );


	/**
	 * Creates a Proto4xUHSParser.
	 */
	public Proto4xUHSParser() {
	}


	/**
	 * Reads a Proto4xUHS file into a List of text lines.
	 * Then calls an appropriate parser to construct a UHSRootNode and a tree of UHSNodes.
	 *
	 * <p>This is likely the only method you'll need.</p>
	 *
	 * @param f  a file to read
	 * @param auxStyle  option for 9x files AUX_NORMAL, AUX_IGNORE, or AUX_NEST
	 * @return the root of a tree of nodes representing the hint file
	 * @see #parse4xFormat(Proto4xUHSParseContext, int)
	 */
	public UHSRootNode parseFile( File f, int auxStyle ) throws IOException, UHSParseException {
		if ( auxStyle != AUX_NORMAL && auxStyle != AUX_IGNORE && auxStyle != AUX_NEST ) {
			throw new IllegalArgumentException( String.format( "Invalid auxStyle: %d", auxStyle ) );
		};
		int index = -1;

		List<String> allLines = new ArrayList<String>();

		RandomAccessFile inFile = new RandomAccessFile( f, "r" );

		index++;
		String tmp = inFile.readLine();
		if (!tmp.equals( "proto_UHS" )) {
			UHSParseException pe = new UHSParseException( "Not a UHS file! (First bytes were not 'proto_UHS')" );
			throw pe;
		}
		allLines.add( tmp );

		byte tmpByte = -1;
		while ( (tmpByte = (byte)inFile.read()) != -1 ) {
			inFile.getChannel().position( inFile.getChannel().position()-1 );
			index++;
			tmp = inFile.readLine();
			allLines.add( tmp );
		}

		inFile.close();

		Proto4xUHSParseContext context = new Proto4xUHSParseContext();
		context.setFile( f );
		context.setWorkingDir( f.getParentFile() );
		context.setAllLines( allLines );
		context.setLineFudge( 0 );

		UHSRootNode rootNode = parse4xFormat( context, auxStyle );
		return rootNode;
	}


	/**
	 * Generates a tree of UHSNodes from Proto UHS 4.x.
	 *
	 * <p>These have not been seen in the wild.</p>
	 *
	 * <p>They're unencrypted and intended to be submitted by
	 * authors directly to the publisher. Oddly,
	 * UHS Source Editor 4.x (and presumably this format) doesn't
	 * fully support the features in the UHS 9x formats.</p>
	 *
	 * <p>Each node is given an arbitrary id on its START
	 * line, and it encloses everything until a matching END line.</p>
	 *
	 * <blockquote><pre>
	 * {@code
	 * proto_UHS
	 * 0 proto_subject
	 * START *********** #
	 * title
	 * ...
	 * =
	 * ...
	 * END *********** #
	 * 0 proto_info
	 * START *********** #
	 * title File Information
	 * ...
	 * END *********** #
	 * }
	 * </pre></blockquote>
	 *
	 * <p>The root node would normally contain up to two children.
	 * <ul>
	 * <li>A 'subject', containing all the subjects, hints, etc., that users care about.</li>
	 * <li>An 'info', mentioning the author, publisher, etc.</li>
	 * </ul></p>
	 *
	 * <p>For convenience, these auxiliary nodes can be treated differently.</p>
	 *
	 * @param context  the parse context
	 * @param auxStyle  AUX_NORMAL (canon), AUX_IGNORE (omit), or AUX_NEST (move inside the master subject and make that the new root).
	 * @return the root of a tree of nodes
	 * @see #buildNodes(Proto4xUHSParseContext, UHSNode, int)
	 */
	public UHSRootNode parse4xFormat( Proto4xUHSParseContext context, int auxStyle ) throws UHSParseException {
		if ( auxStyle != AUX_NORMAL && auxStyle != AUX_IGNORE && auxStyle != AUX_NEST )  {
			throw new IllegalArgumentException( String.format( "Invalid auxStyle: %d", auxStyle ) );
		};

		try {
			UHSRootNode rootNode = new UHSRootNode();
				rootNode.setRawStringContent( "Root" );
				context.setRootNode( rootNode );

			int index = 1;
			index += buildNodes( context, rootNode, index );

			if ( auxStyle != AUX_IGNORE ) {
				if ( auxStyle == AUX_NEST ) {
					UHSNode subjectNode = rootNode.getFirstChild( "proto_subject", UHSNode.class );

					rootNode.setChildren( subjectNode.getChildren() );

					rootNode.setRawStringContent( subjectNode.getRawStringContent() );

					UHSNode blankNode = new UHSNode( "Blank" );
						blankNode.setRawStringContent( "--=File Info=--" );
						rootNode.addChild( blankNode );
				}
				while ( context.hasLine( index ) ) {
					index += buildNodes( context, rootNode, index );
				}
			}
			return rootNode;
		}
		catch ( NumberFormatException e ) {
			UHSParseException pe = new UHSParseException( String.format( "Unable to parse nodes (last parsed line: %d)", context.getLastParsedLineNumber() ), e );
			throw pe;
		}
		catch ( ArrayIndexOutOfBoundsException e ) {
			UHSParseException pe = new UHSParseException( String.format( "Unable to parse nodes (last parsed line: %d)", context.getLastParsedLineNumber() ), e );
			throw pe;
		}
	}


	/**
	 * Recursively parses Proto UHS.
	 *
	 * <p>This recognizes various types of hints, and runs specialized methods to decode them.
	 * Unrecognized hints are harmlessly omitted.</p>
	 *
	 * @param context  the parse context
	 * @param currentNode  an existing node to add children to
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int buildNodes( Proto4xUHSParseContext context, UHSNode currentNode, int startIndex ) {
		int index = startIndex;

		String tmp = context.getLine( index );
		if ( tmp.matches( "[0-9]+ [A-Za-z_]+$" ) ) {
			if ( tmp.endsWith( "proto_subject" ) ) {
				index += parseSubjectNode( context, currentNode, index );
			}
			else if ( tmp.endsWith( "proto_hint" ) ) {
				index += parseHintNode( context, currentNode, index );
			}
			else if ( tmp.endsWith( "proto_text" ) ) {
				index += parseTextNode( context, currentNode, index );
			}
			else if ( tmp.endsWith( "proto_comment" ) ) {
				index += parseCommentNode( context, currentNode, index );
			}
			else if ( tmp.endsWith( "proto_credit" ) ) {
				index += parseCreditNode( context, currentNode, index );
			}
			else if ( tmp.endsWith( "proto_link" ) ) {
				index += parseLinkNode( context, currentNode, index );
			}
			else if ( tmp.endsWith( "proto_hyperpng" ) ) {
				index += parseHyperImageNode( context, currentNode, index );
			}
			else if ( tmp.endsWith( "proto_info" ) ) {
				index += parseInfoNode( context, currentNode, index );
			}
			else {
				index += parseUnknownNode( context, currentNode, index );
			}
		}
		else {
			index++;
		}

		return index-startIndex;
	}

	/**
	 * Replaces UHS escaped characters in a hint.
	 *
	 * <p>Escapes have existed from version 88a onwards in most nodes' content and titles.</p>
	 *
	 * <p>The # character is the main escape char and is written <b>##</b>.</p>
	 *
	 * <p><ul>
	 * <li><b>#</b> a '#' character.</li>
	 * <li><b>#a+</b>[AaEeIiOoUu][:'`^]<b>#a-</b> accent enclosed letter; :=diaeresis,'=acute,`=grave,^=circumflex.</li>
	 * <li><b>#a+</b>[Nn]~<b>#a-</b> accent enclosed letter with a tilde.</li>
	 * <li><b>#a+</b>ae<b>#a-</b> an ash character.</li>
	 * <li><b>#a+</b>TM<b>#a-</b> a trademark character.</li>
	 * <li><b>#w.</b> raw newlines are spaces.</li>
	 * <li><b>#w+</b> raw newlines are spaces (default).</li>
	 * <li><b>#w-</b> raw newlines are newlines.</li>
	 * </ul></p>
	 *
	 * <p>The following are left for display code to handle (e.g., UHSTextArea).
	 * <ul>
	 * <li><b>#p+</b> proportional font (default).</li>
	 * <li><b>#p-</b> non-proportional font.</li>
	 * </ul></p>
	 *
	 * <p>This is displayed, but not a clickable hyperlink.
	 * <ul>
	 * <li><b>#h+</b> through <b>#h-</b> is a hyperlink (http or email).</li>
	 * </ul></p>
	 *
	 * <p>TODO: This needs to be delegated to node content decorators.</p>
	 *
	 * <p><ul>
	 * <li>Illustrative UHS: <i>Portal: Achievements</i> (hyperlink)</li>
	 * </ul></p>
	 *
	 * @param currentNode  the node whose content needs replacing
	 */
	public void parseTextEscapes( UHSNode currentNode ) {

		char[] linebreak = new char[] {'^','b','r','e','a','k','^'};
		char[] accentPrefix = new char[] {'#','a','+'};
		char[] accentSuffix = new char[] {'#','a','-'};
		char[] wspcA = new char[] {'#','w','+'};
		char[] wspcB = new char[] {'#','w','.'};
		char[] wnlin = new char[] {'#','w','-'};

		StringBuffer buf = new StringBuffer();
		char[] tmp = currentNode.getRawStringContent().toCharArray();
		String breakStr = " ";
		char[] chunkA = null;
		char[] chunkB = null;
		boolean fudgedPos = false;

		for ( int c=0; c < tmp.length; c++ ) {
			if ( c+1 < tmp.length ) {
				if ( tmp[c] == '#' && tmp[c+1] == '#' ) {buf.append( '#' ); c+=1; continue;}
			}
			if ( tmp[c] == '#' ) {
				if ( c+7 < tmp.length ) {
					chunkA = new char[] {tmp[c],tmp[c+1],tmp[c+2]};
					chunkB = new char[] {tmp[c+5],tmp[c+6],tmp[c+7]};
					if ( Arrays.equals( chunkA, accentPrefix ) && Arrays.equals( chunkB, accentSuffix ) ) {
						if ( tmp[c+4] == ':' ) {
							if ( tmp[c+3] == 'A' ) {buf.append( 'Ä' ); c+=7; continue;}
							if ( tmp[c+3] == 'E' ) {buf.append( 'Ë' ); c+=7; continue;}
							if ( tmp[c+3] == 'I' ) {buf.append( 'Ï' ); c+=7; continue;}
							if ( tmp[c+3] == 'O' ) {buf.append( 'Ö' ); c+=7; continue;}
							if ( tmp[c+3] == 'U' ) {buf.append( 'Ü' ); c+=7; continue;}
							if ( tmp[c+3] == 'a' ) {buf.append( 'ä' ); c+=7; continue;}
							if ( tmp[c+3] == 'e' ) {buf.append( 'ë' ); c+=7; continue;}
							if ( tmp[c+3] == 'i' ) {buf.append( 'ï' ); c+=7; continue;}
							if ( tmp[c+3] == 'o' ) {buf.append( 'ö' ); c+=7; continue;}
							if ( tmp[c+3] == 'u' ) {buf.append( 'ü' ); c+=7; continue;}
						}
						else if ( tmp[c+4] == '\'' ) {
							if ( tmp[c+3] == 'A' ) {buf.append( 'Á' ); c+=7; continue;}
							if ( tmp[c+3] == 'E' ) {buf.append( 'É' ); c+=7; continue;}
							if ( tmp[c+3] == 'I' ) {buf.append( 'Í' ); c+=7; continue;}
							if ( tmp[c+3] == 'O' ) {buf.append( 'Ó' ); c+=7; continue;}
							if ( tmp[c+3] == 'U' ) {buf.append( 'Ú' ); c+=7; continue;}
							if ( tmp[c+3] == 'a' ) {buf.append( 'á' ); c+=7; continue;}
							if ( tmp[c+3] == 'e' ) {buf.append( 'é' ); c+=7; continue;}
							if ( tmp[c+3] == 'i' ) {buf.append( 'í' ); c+=7; continue;}
							if ( tmp[c+3] == 'o' ) {buf.append( 'ó' ); c+=7; continue;}
							if ( tmp[c+3] == 'u' ) {buf.append( 'ú' ); c+=7; continue;}
						}
						else if ( tmp[c+4] == '`' ) {
							if ( tmp[c+3] == 'A' ) {buf.append( 'À' ); c+=7; continue;}
							if ( tmp[c+3] == 'E' ) {buf.append( 'È' ); c+=7; continue;}
							if ( tmp[c+3] == 'I' ) {buf.append( 'Ì' ); c+=7; continue;}
							if ( tmp[c+3] == 'O' ) {buf.append( 'Ò' ); c+=7; continue;}
							if ( tmp[c+3] == 'U' ) {buf.append( 'Ù' ); c+=7; continue;}
							if ( tmp[c+3] == 'a' ) {buf.append( 'à' ); c+=7; continue;}
							if ( tmp[c+3] == 'e' ) {buf.append( 'è' ); c+=7; continue;}
							if ( tmp[c+3] == 'i' ) {buf.append( 'ì' ); c+=7; continue;}
							if ( tmp[c+3] == 'o' ) {buf.append( 'ò' ); c+=7; continue;}
							if ( tmp[c+3] == 'u' ) {buf.append( 'ù' ); c+=7; continue;}
						}
						else if ( tmp[c+4] == '^' ) {
							if ( tmp[c+3] == 'A' ) {buf.append( 'Â' ); c+=7; continue;}
							if ( tmp[c+3] == 'E' ) {buf.append( 'Ê' ); c+=7; continue;}
							if ( tmp[c+3] == 'I' ) {buf.append( 'Î' ); c+=7; continue;}
							if ( tmp[c+3] == 'O' ) {buf.append( 'Ô' ); c+=7; continue;}
							if ( tmp[c+3] == 'U' ) {buf.append( 'Û' ); c+=7; continue;}
							if ( tmp[c+3] == 'a' ) {buf.append( 'â' ); c+=7; continue;}
							if ( tmp[c+3] == 'e' ) {buf.append( 'ê' ); c+=7; continue;}
							if ( tmp[c+3] == 'i' ) {buf.append( 'î' ); c+=7; continue;}
							if ( tmp[c+3] == 'o' ) {buf.append( 'ô' ); c+=7; continue;}
							if ( tmp[c+3] == 'u' ) {buf.append( 'û' ); c+=7; continue;}
						}
						else if ( tmp[c+4] == '~' ) {
							if ( tmp[c+3] == 'N' ) {buf.append( 'Ñ' ); c+=7; continue;}
							if ( tmp[c+3] == 'n' ) {buf.append( 'ñ' ); c+=7; continue;}
						}
						else if ( tmp[c+3] == 'a' && tmp[c+4] == 'e' ) {
							buf.append( 'æ' ); c+=7; continue;
						}
						else if ( tmp[c+3] == 'T' && tmp[c+4] == 'M' ) {
							buf.append( '™' ); c+=7; continue;
						}
						else {
							logger.warn( "Parser encountered an unexpected accent ({}) in this line: {}", (tmp[c+3] + tmp[c+4]), currentNode.getRawStringContent() );
						}
					}
				}
				if ( c+2 < tmp.length ) {
					chunkA = new char[] {tmp[c],tmp[c+1],tmp[c+2]};
					if ( Arrays.equals( chunkA, wspcA ) || Arrays.equals( chunkA, wspcB ) ) {
						breakStr = " "; c+=2; continue;
					}
					else if ( Arrays.equals( chunkA, wnlin ) ) {
						breakStr = "\n"; c+=2; continue;
					}
				}
			}
			if ( c+6 < tmp.length ) {
				chunkA = new char[] {tmp[c],tmp[c+1],tmp[c+2],tmp[c+3],tmp[c+4],tmp[c+5],tmp[c+6]};
				if ( Arrays.equals( chunkA, linebreak ) ) {
					buf.append( breakStr ); c += 6; continue;
				}
			}
			buf.append( tmp[c] );
		}

		currentNode.setRawStringContent( buf.toString() );
	}

	/**
	 * Generates a subject UHSNode and its contents.
	 *
	 * <blockquote><pre>
	 * {@code
	 * 0 proto_subject
	 * START *********** #
	 * title
	 * =
	 * embedded hunk
	 * =
	 * embedded hunk
	 * END *********** #
	 * }
	 * </pre></blockquote>
	 *
	 * @param context  the parse context
	 * @param currentNode  an existing node to add children to
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseSubjectNode( Proto4xUHSParseContext context, UHSNode currentNode, int startIndex ) {
		int index = startIndex;
		Matcher startMatcher = null;
		Matcher endMatcher = null;
		String[] tokens = null;
		String tmp = context.getLine( index );  // Not interesting.
		index++;

		startMatcher = startPtn.matcher( context.getLine( index ) );
		index++;
		startMatcher.matches();
		int subjectId = Integer.parseInt( startMatcher.group( 1 ) );

		int restriction = UHSNode.RESTRICT_NONE;
		if ( "Z".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_NAG;
		}
		else if ( "A".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode subjectNode = new UHSNode( "Subject" );
			subjectNode.setRawStringContent( context.getLine( index ) );
			parseTextEscapes( subjectNode );
			subjectNode.setId( subjectId );
			subjectNode.setRestriction( restriction );
			currentNode.addChild( subjectNode );
			context.getRootNode().addLink( subjectNode );
		index++;

		while ( context.hasLine( index ) ) {
			tmp = context.getLine( index );
			index++;
			endMatcher = endPtn.matcher( tmp );
			if ( endMatcher.matches() && endMatcher.group( 1 ).equals( subjectId +"" ) ) {
				break;
			}
			else if ( tmp.equals( "=" ) ) {
				index += buildNodes( context, subjectNode, index );
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates a normal hint UHSNode.
	 *
	 * <blockquote><pre>
	 * {@code
	 * 0 proto_hint
	 * START *********** #
	 * Question
	 * hint (not encrypted)
	 * -
	 * hint (not encrypted)
	 * END *********** #
	 * }
	 * </pre></blockquote>
	 *
	 * @param context  the parse context
	 * @param currentNode  an existing node to add children to
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseHintNode( Proto4xUHSParseContext context, UHSNode currentNode, int startIndex ) {
		String breakChar = "^break^";

		int index = startIndex;
		Matcher startMatcher = null;
		Matcher endMatcher = null;
		String[] tokens = null;
		String tmp = context.getLine( index );  // Not interesting.
		index++;

		startMatcher = startPtn.matcher( context.getLine( index ) );
		index++;
		startMatcher.matches();
		int hintId = Integer.parseInt( startMatcher.group( 1 ) );

		int restriction = UHSNode.RESTRICT_NONE;
		if ( "Z".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_NAG;
		}
		else if ( "A".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode hintNode = new UHSNode( "Hint" );
			hintNode.setRawStringContent( context.getLine( index ) );
			parseTextEscapes( hintNode );
			hintNode.setId( hintId );
			hintNode.setRestriction( restriction );
			currentNode.addChild( hintNode );
			context.getRootNode().addLink( hintNode );
		index++;

		StringBuffer tmpContent = new StringBuffer();
		UHSNode newNode = new UHSNode( "Hint" );

		while ( context.hasLine( index ) ) {
			tmp = context.getLine( index );
			index++;
			endMatcher = endPtn.matcher( tmp );
			if ( endMatcher.matches() && endMatcher.group( 1 ).equals( hintId +"" ) ) {
				if ( tmpContent.length() > 0 ) {
					newNode.setRawStringContent( tmpContent.toString() );
					parseTextEscapes( newNode );
					hintNode.addChild( newNode );
				}
				break;
			}
			else if ( tmp.equals( "-" ) ) {
				if ( tmpContent.length() > 0 ) {
					newNode.setRawStringContent( tmpContent.toString() );
					parseTextEscapes( newNode );
					hintNode.addChild( newNode );
					newNode = new UHSNode( "Hint" );
					tmpContent.delete( 0, tmpContent.length() );
				}
			}
			else {
				if ( tmpContent.length() > 0 ) tmpContent.append( breakChar );

				if ( tmp.equals( " " ) ) tmpContent.append( "\n \n" );
				else tmpContent.append( tmp );
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates a text UHSNode.
	 *
	 * <blockquote><pre>
	 * {@code
	 * 0 proto_text
	 * START *********** #
	 * title
	 * sentence
	 * sentence
	 * sentence
	 * END *********** #
	 * }
	 * </pre></blockquote>
	 *
	 * <p>Rather than assuming "\n" everywhere, in-file linebreaks
	 * are preserved (for context-sensitive escaping later).
	 * Markup will be inserted to begin with that as the default.</p>
	 *
	 * @param context  the parse context
	 * @param currentNode  an existing node to add children to
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseTextNode( Proto4xUHSParseContext context, UHSNode currentNode, int startIndex ) {
		String breakChar = "^break^";

		int index = startIndex;
		Matcher startMatcher = null;
		Matcher endMatcher = null;
		String[] tokens = null;
		String tmp = context.getLine( index );  // Not interesting.
		index++;

		startMatcher = startPtn.matcher( context.getLine( index ) );
		index++;
		startMatcher.matches();
		int textId = Integer.parseInt( startMatcher.group( 1 ) );

		int restriction = UHSNode.RESTRICT_NONE;
		if ( "Z".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_NAG;
		}
		else if ( "A".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode textNode = new UHSNode( "Text" );
			textNode.setRawStringContent( context.getLine( index ) );
			parseTextEscapes( textNode );
			textNode.setId( textId );
			textNode.setRestriction( restriction );
			currentNode.addChild( textNode );
			context.getRootNode().addLink( textNode );
		index++;

		StringBuffer tmpContent = new StringBuffer();
		UHSNode newNode = new UHSNode( "TextData" );

		while ( context.hasLine( index ) ) {
			tmp = context.getLine( index );
			index++;
			endMatcher = endPtn.matcher( tmp );
			if ( endMatcher.matches() && endMatcher.group( 1 ).equals( textId +"" ) ) {
				if ( tmpContent.length() > 0 ) {
					if ( tmpContent.length() < 3 || !tmpContent.substring( 0, 3 ).startsWith( "#w-" ) ) {
						tmpContent.insert( 0, "#w-" );  // Text nodes default to honoring newlines.
					}
					newNode.setRawStringContent( tmpContent.toString() );
					parseTextEscapes( newNode );
					textNode.addChild( newNode );
				}
				break;
			}
			else {
				if ( tmpContent.length() > 0 ) tmpContent.append( breakChar );

				if ( tmp.equals( " " ) ) tmpContent.append( "\n \n" );
				else tmpContent.append( tmp );
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates a comment UHSNode.
	 *
	 * <blockquote><pre>
	 * {@code
	 * 0 proto_comment
	 * START *********** #
	 * title
	 * sentence
	 * sentence
	 * sentence
	 * END *********** #
	 * }
	 * </pre></blockquote>
	 *
	 * <p>Rather than assuming " " everywhere, in-file linebreaks
	 * are preserved (for context-sensitive escaping later).
	 * Markup will be inserted to begin with that as the default.</p>
	 *
	 * @param context  the parse context
	 * @param currentNode  an existing node to add children to
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseCommentNode( Proto4xUHSParseContext context, UHSNode currentNode, int startIndex ) {
		String breakChar = "^break^";

		int index = startIndex;
		Matcher startMatcher = null;
		Matcher endMatcher = null;
		String[] tokens = null;
		String tmp = context.getLine( index );  // Not interesting.
		index++;

		startMatcher = startPtn.matcher( context.getLine( index ) );
		index++;
		startMatcher.matches();
		int commentId = Integer.parseInt( startMatcher.group( 1 ) );

		int restriction = UHSNode.RESTRICT_NONE;
		if ( "Z".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_NAG;
		}
		else if ( "A".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode commentNode = new UHSNode( "Comment" );
			commentNode.setRawStringContent( context.getLine( index ) );
			parseTextEscapes( commentNode );
			commentNode.setId( commentId );
			commentNode.setRestriction( restriction );
			currentNode.addChild( commentNode );
			context.getRootNode().addLink( commentNode );
		index++;

		StringBuffer tmpContent = new StringBuffer();
		UHSNode newNode = new UHSNode( "CommentData" );

		while ( context.hasLine( index ) ) {
			tmp = context.getLine( index );
			index++;
			endMatcher = endPtn.matcher( tmp );
			if ( endMatcher.matches() && endMatcher.group( 1 ).equals( commentId +"" ) ) {
				if ( tmpContent.length() > 0 ) {
					newNode.setRawStringContent( tmpContent.toString() );
					parseTextEscapes( newNode );
					commentNode.addChild( newNode );
				}
				break;
			}
			else {
				if ( tmpContent.length() > 0 ) tmpContent.append( breakChar );

				if ( tmp.equals( " " ) ) tmpContent.append( "\n \n" );
				else tmpContent.append( tmp );
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates a credit UHSNode.
	 *
	 * <blockquote><pre>
	 * {@code
	 * 0 proto_credit
	 * START *********** #
	 * title
	 * sentence
	 * sentence
	 * sentence
	 * END *********** #
	 * }
	 * </pre></blockquote>
	 *
	 * <p>Rather than assuming " " everywhere, in-file linebreaks
	 * are preserved (for context-sensitive escaping later).
	 * Markup will be inserted to begin with that as the default.</p>
	 *
	 * @param context  the parse context
	 * @param currentNode  an existing node to add children to
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseCreditNode( Proto4xUHSParseContext context, UHSNode currentNode, int startIndex ) {
		String breakChar = "^break^";

		int index = startIndex;
		Matcher startMatcher = null;
		Matcher endMatcher = null;
		String[] tokens = null;
		String tmp = context.getLine( index );  // Not interesting.
		index++;

		startMatcher = startPtn.matcher( context.getLine( index ) );
		index++;
		startMatcher.matches();
		int creditId = Integer.parseInt( startMatcher.group( 1 ) );

		int restriction = UHSNode.RESTRICT_NONE;
		if ( "Z".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_NAG;
		}
		else if ( "A".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode creditNode = new UHSNode( "Credit" );
			creditNode.setRawStringContent( context.getLine( index ) );
			parseTextEscapes( creditNode );
			creditNode.setId( creditId );
			creditNode.setRestriction( restriction );
			currentNode.addChild( creditNode );
			context.getRootNode().addLink( creditNode );
		index++;

		StringBuffer tmpContent = new StringBuffer();
		UHSNode newNode = new UHSNode( "CreditData" );

		while ( context.hasLine( index ) ) {
			tmp = context.getLine( index );
			index++;
			endMatcher = endPtn.matcher( tmp );
			if ( endMatcher.matches() && endMatcher.group( 1 ).equals( creditId +"" ) ) {
				if ( tmpContent.length() > 0 ) {
					newNode.setRawStringContent( tmpContent.toString() );
					parseTextEscapes( newNode );
					creditNode.addChild( newNode );
				}
				break;
			}
			else {
				if ( tmpContent.length() > 0 ) tmpContent.append( breakChar );

				if ( tmp.equals(" ") ) tmpContent.append( "\n \n" );
				else tmpContent.append( tmp );
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates a link UHSNode.
	 *
	 * <p>Nodes like this that have link targets behave like conventional hyperlinks instead of containing child nodes.</p>
	 *
	 * <blockquote><pre>
	 * {@code
	 * 0 proto_link
	 * START *********** #
	 * title
	 * index
	 * END *********** #
	 * }
	 * </pre></blockquote>
	 *
	 * @param context  the parse context
	 * @param currentNode  an existing node to add children to
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseLinkNode( Proto4xUHSParseContext context, UHSNode currentNode, int startIndex ) {
		int index = startIndex;
		Matcher startMatcher = null;
		Matcher endMatcher = null;
		String[] tokens = null;
		String tmp = context.getLine( index );  // Not interesting.
		index++;

		startMatcher = startPtn.matcher( context.getLine( index ) );
		index++;
		startMatcher.matches();
		int linkId = Integer.parseInt( startMatcher.group( 1 ) );

		int restriction = UHSNode.RESTRICT_NONE;
		if ( "Z".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_NAG;
		}
		else if ( "A".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode linkNode = new UHSNode( "Link" );
			linkNode.setRawStringContent( context.getLine( index ) );
			parseTextEscapes( linkNode );
			linkNode.setId( linkId );
			linkNode.setRestriction( restriction );
			currentNode.addChild( linkNode );
			context.getRootNode().addLink( linkNode );
		index++;

		int targetIndex = Integer.parseInt( context.getLine( index ) );
			linkNode.setLinkTarget( targetIndex );
		index++;

		while ( context.hasLine( index ) ) {
			tmp = context.getLine( index );
			index++;
			endMatcher = endPtn.matcher( tmp );
			if ( endMatcher.matches() && endMatcher.group( 1 ).equals( linkId +"" ) ) {
				break;
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates an image-filled UHSNode.
	 *
	 * <p>The UHS format allows for regions that trigger links or reveal overlaid subimages.</p>
	 *
	 * <p>UHSHotSpotNode was written to handle regions.</p>
	 *
	 * <blockquote><pre>
	 * {@code
	 * 0 proto_hyperpng
	 * START *********** #
	 * title
	 * file-path 0 0
	 * --not-a-gap--
	 * x y x+w y+h
	 * 0 proto_link
	 * START *********** #
	 * title
	 * index
	 * END *********** #
	 * --not-a-gap--
	 * x y x+w y+h
	 * 0 proto_link
	 * START *********** #
	 * title
	 * index
	 * END *********** #
	 * --not-a-gap--
	 * x y x+w y+h
	 * 0 proto_overlay
	 * START *********** #
	 * title
	 * file-path 0 0 x y
	 * END *********** #
	 * --not-a-gap--
	 * x y x+w y+h
	 * 0 proto_overlay
	 * START *********** #
	 * title
	 * file-path 0 0 x y
	 * END *********** #
	 * }
	 * </pre></blockquote>
	 *
	 * <p>Paths point to png images (spaces are replaced with "?").</p>
	 * <p>There is no comparable gifa structure.</p>
	 *
	 * <p>To create this in the UHS Source Editor...
	 * <ul>
	 * <li>Add_Menu-HyperPNG, pick a title and image.</li>
	 * <li> - Add_Menu-Link, pick a target.</li>
	 * <li> - - Highlight the link in the list, then drag a region on the image.</li>
	 * <li> - Add_Menu-Overlay, pick a title and image.</li>
	 * <li> - - Click somewhere in the overlay popup's image to set the top-left.</li>
	 * <li> - - Close the overlay's popup.</li>
	 * <li> - - Highlight the overlay in the list, then drag a region on the image.</li>
	 * </ul></p>
	 *
	 * @param context  the parse context
	 * @param currentNode  an existing node to add children to
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file in parsing children
	 * @see net.vhati.openuhs.core.UHSHotSpotNode
	 */
	public int parseHyperImageNode( Proto4xUHSParseContext context, UHSNode currentNode, int startIndex ) {
		int index = startIndex;
		Matcher startMatcher = null;
		Matcher endMatcher = null;
		String[] tokens = null;
		byte[] tmpBytes = null;
		int x = 0;
		int y = 0;
		String tmp = context.getLine( index );  // Not interesting.
		index++;

		startMatcher = startPtn.matcher( context.getLine( index ) );
		index++;
		startMatcher.matches();
		int hyperId = Integer.parseInt( startMatcher.group( 1 ) );

		int restriction = UHSNode.RESTRICT_NONE;
		if ( "Z".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_NAG;
		}
		else if ( "A".equals( startMatcher.group( 2 ) ) ) {
			restriction = UHSNode.RESTRICT_REGONLY;
		}

		String mainTitle = context.getLine( index );
		index++;

		tokens = context.getLine( index ).split( " " );
		index++;
		if ( tokens.length != 3 ) {
			logger.error( "Unable to parse HyperImage's main image path (last parsed line: {})", context.getLastParsedLineNumber() );

			index += skipToEnd( context, hyperId, index );
			return index-startIndex;
		}
		String mainImagePath = tokens[0].replaceAll( "[?]", " " ).replace( '\\', '/' );
		File mainImageFile = null;
		if ( mainImagePath.startsWith( "." ) ) {
			mainImageFile = new File( context.getWorkingDir(), mainImagePath );
		}
		else {
			mainImageFile = new File( mainImagePath );
		}

		tmpBytes = null;
		try {
			tmpBytes = readBytesFromFile( mainImageFile );
		}
		catch ( IOException e ) {
			logger.error( "Could not read referenced file: {} (last parsed line: {})", mainImageFile.getAbsolutePath(), context.getLastParsedLineNumber(), e );
		}
		// Ignore dummy zeroes after the path.

		UHSHotSpotNode hotspotNode = new UHSHotSpotNode( "Hyperpng" );
			hotspotNode.setRawStringContent( mainTitle );
			hotspotNode.setRawImageContent( tmpBytes );
			hotspotNode.setId( hyperId );
			hotspotNode.setRestriction( restriction );
			currentNode.addChild( hotspotNode );
			context.getRootNode().addLink( hotspotNode );

		Pattern zonePtn = Pattern.compile( "([0-9]+) ([0-9]+) ([0-9]+) ([0-9]+)\\s*$" );
		Pattern overlayPathPosPtn = Pattern.compile( "\\S+ (0) (0) ([0-9]+) ([0-9]+)\\s*$" );
		Matcher zoneMatcher = null;
		Matcher overlayPathPosMatcher = null;

		while ( context.hasLine( index ) ) {
			tmp = context.getLine( index );
			index++;
			if ( (endMatcher = endPtn.matcher( tmp )).matches() && endMatcher.group( 1 ).equals( hyperId +"" ) ) {
				break;
			}
			else if ( (zoneMatcher = zonePtn.matcher( tmp )).matches() ) {
				int zoneX1 = Integer.parseInt( zoneMatcher.group( 1 ) )-1;
				int zoneY1 = Integer.parseInt( zoneMatcher.group( 2 ) )-1;
				int zoneX2 = Integer.parseInt( zoneMatcher.group( 3 ) )-1;
				int zoneY2 = Integer.parseInt( zoneMatcher.group( 4 ) )-1;

				if ( zoneX1 > zoneX2 || zoneY1 > zoneY2 ) {
					logger.error( "Invalid HyperImage zone coordinates (last parsed line: {})", context.getLastParsedLineNumber() );

					index += skipToEnd( context, hyperId, index );
					return index-startIndex;
				}

				tmp = context.getLine( index );
				index++;
				if ( tmp.matches( "[0-9]+ [A-Za-z_]+$" ) ) {
					if ( tmp.endsWith( "proto_overlay" ) ) {
						startMatcher = startPtn.matcher( context.getLine( index ) );
						index++;
						startMatcher.matches();
						int overlayId = Integer.parseInt( startMatcher.group( 1 ) );

						String overlayTitle = context.getLine( index );
						index++;

						overlayPathPosMatcher = overlayPathPosPtn.matcher( context.getLine( index ) );
						index++;
						overlayPathPosMatcher.matches();

						String overlayImagePath = overlayPathPosMatcher.group( 1 ).replaceAll( "[?]", " " ).replace( '\\', '/' );

						File overlayImageFile = null;
						if ( overlayImagePath.startsWith( "." ) ) {
							overlayImageFile = new File( context.getWorkingDir(), overlayImagePath );
						} else {
							overlayImageFile = new File( overlayImagePath );
						}
						// Skip dummy zeroes after the path.
						int posX = Integer.parseInt( overlayPathPosMatcher.group( 4 ) )-1;
						int posY = Integer.parseInt( overlayPathPosMatcher.group( 5 ) )-1;

						tmpBytes = null;
						try {
							tmpBytes = readBytesFromFile( overlayImageFile );
						}
						catch ( IOException e ) {
							logger.error( "Could not read referenced file: {} (last parsed line: {})", overlayImageFile.getAbsolutePath(), context.getLastParsedLineNumber(), e );
							// TODO: Throw an error.
						}

						UHSImageNode overlayNode = new UHSImageNode( "Overlay" );
							overlayNode.setRawStringContent( overlayTitle );
							overlayNode.setRawImageContent( tmpBytes );
							overlayNode.setId( overlayId );
							context.getRootNode().addLink( overlayNode );
							hotspotNode.addChild( overlayNode );
							hotspotNode.setSpot( overlayNode, new HotSpot( zoneX1, zoneY1, zoneX2-zoneX1, zoneY2-zoneY1, posX, posY ) );

						index++;  // This should skip the overlay's END line.
					}
					else if ( tmp.endsWith( "proto_link" ) ) {
						startMatcher = startPtn.matcher( context.getLine( index ) );
						index++;
						startMatcher.matches();
						int linkId = Integer.parseInt( startMatcher.group( 1 ) );

						String linkTitle = context.getLine( index );
						index++;

						int targetIndex = Integer.parseInt( context.getLine( index ) );
						index++;

						UHSNode newNode = new UHSNode( "Link" );
							newNode.setRawStringContent( linkTitle );
							parseTextEscapes( newNode );
							newNode.setId( linkId );
							context.getRootNode().addLink( newNode );
							hotspotNode.addChild( newNode );
							hotspotNode.setSpot( newNode, new HotSpot( zoneX1, zoneY1, zoneX2-zoneX1, zoneY2-zoneY1, -1, -1 ) );
							newNode.setLinkTarget( targetIndex );

						index++;  // This should skip the link's END line.
					}
					else {
						logger.error( "Unexpected {} child of HyperImage (last parsed line: {})", tmp, context.getLastParsedLineNumber() );

						index += skipToEnd( context, hyperId, index );
						return index-startIndex;
					}
				}
				else {
					logger.error( "Unexpected line in HyperImage: {} (last parsed line: {})", tmp, context.getLastParsedLineNumber() );

					index += skipToEnd( context, hyperId, index );
					return index-startIndex;
				}
			}
			else {
				logger.error( "Unexpected line in HyperImage: {} (last parsed line: {})", tmp, context.getLastParsedLineNumber() );

				index += skipToEnd( context, hyperId, index );
				return index-startIndex;
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates an info UHSNode.
	 *
	 * <blockquote><pre>
	 * {@code
	 * 0 proto_info
	 * START *********** #
	 * title
	 * author=name
	 * publisher=name
	 * author-note=sentence
	 * game-note=sentence
	 * copyright=sentence
	 * comments=sentence
	 * END *********** #
	 * }
	 * </pre></blockquote>
	 *
	 * @param context  the parse context
	 * @param currentNode  an existing node to add children to
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseInfoNode( Proto4xUHSParseContext context, UHSNode currentNode, int startIndex ) {
		String breakChar = " ";

		int index = startIndex;
		Matcher startMatcher = null;
		Matcher endMatcher = null;
		String[] tokens = null;
		String tmp = context.getLine( index );  // Not interesting.
		index++;

		startMatcher = startPtn.matcher( context.getLine( index ) );
		index++;
		startMatcher.matches();
		int infoId = Integer.parseInt( startMatcher.group( 1 ) );

		int restriction = UHSNode.RESTRICT_NONE;
		// Don't bother with restriction.

		UHSNode infoNode = new UHSNode( "Info" );
			infoNode.setRawStringContent( context.getLine( index ) );
			parseTextEscapes( infoNode );
			infoNode.setId( infoId );
			currentNode.addChild( infoNode );
			context.getRootNode().addLink( infoNode );
		index++;

		StringBuffer authorBuf = new StringBuffer();
		StringBuffer publisherBuf = new StringBuffer();
		StringBuffer authorNoteBuf = new StringBuffer();
		StringBuffer gameNoteBuf = new StringBuffer();
		StringBuffer copyrightBuf = new StringBuffer();
		StringBuffer noticeBuf = new StringBuffer();  // "comments="

		StringBuffer unknownBuf = new StringBuffer();
		StringBuffer[] buffers = new StringBuffer[] {authorBuf, publisherBuf, authorNoteBuf, gameNoteBuf, copyrightBuf, noticeBuf, unknownBuf};

		StringBuffer tmpContent = new StringBuffer();
		StringBuffer currentBuffer = null;
		UHSNode newNode = new UHSNode( "InfoData" );

		while ( context.hasLine( index ) ) {
			tmp = context.getLine( index );
			index++;

			if ( tmp.startsWith( "copyright" ) || tmp.startsWith( "author-note" ) || tmp.startsWith( "game-note" ) || tmp.startsWith( "comments" ) ) {
				breakChar = " ";
			}
			else {
				breakChar = "\n";  // The official editor doesn't seem capable of linebreaks
			}

			endMatcher = endPtn.matcher( tmp );
			if ( endMatcher.matches() && endMatcher.group( 1 ).equals( infoId +"" ) ) {
				for ( int i=0; i < buffers.length; i++ ) {
					if ( buffers[i].length() == 0 ) continue;
					if ( tmpContent.length() > 0 ) {
						tmpContent.append( "\n" );
						if ( buffers[i] == authorNoteBuf ||
								buffers[i] == gameNoteBuf ||
								buffers[i] == copyrightBuf ||
								buffers[i] == noticeBuf ) {
							tmpContent.append( "\n" );
						}
					}
					tmpContent.append( buffers[i] );
				}

				newNode.setRawStringContent( tmpContent.toString() );
				parseTextEscapes( newNode );
				infoNode.addChild( newNode );
				break;
			}
			else if ( tmp.startsWith( "author=" ) ) {
				currentBuffer = authorBuf;
				//tmp = tmp.substring( 7 );
			}
			else if ( tmp.startsWith( "publisher=" ) ) {
				currentBuffer = publisherBuf;
				//tmp = tmp.substring( 10 );
			}
			else if ( tmp.startsWith( "author-note=" ) ) {
				currentBuffer = authorNoteBuf;
				if ( currentBuffer.length() == 0 ) {currentBuffer.append( "author-note=" ); breakChar = "";}
				tmp = tmp.substring( 12 );
			}
			else if ( tmp.startsWith( "game-note=" ) ) {
				currentBuffer = gameNoteBuf;
				if ( currentBuffer.length() == 0 ) {currentBuffer.append( "game-note=" ); breakChar = "";}
				tmp = tmp.substring( 10 );
			}
			else if ( tmp.startsWith( "copyright=" ) ) {
				currentBuffer = copyrightBuf;
				if ( currentBuffer.length() == 0 ) {currentBuffer.append( "copyright=" ); breakChar = "";}
				tmp = tmp.substring( 10 );
			}
			else if ( tmp.startsWith("comments=") ) {
				currentBuffer = noticeBuf;
				tmp = tmp.substring( 9 );
			}
			else {
				currentBuffer = unknownBuf;
				logger.warn( "Unknown proto_info hunk line: {} (last parsed line: {})", tmp, context.getLastParsedLineNumber() );
			}

			if ( currentBuffer.length() > 0 ) currentBuffer.append( breakChar );
			currentBuffer.append( tmp );
		}

		return index-startIndex;
	}

	/**
	 * Generates a stand-in UHSNode for an unknown hunk.
	 *
	 * @param context  the parse context
	 * @param currentNode  an existing node to add children to
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseUnknownNode( Proto4xUHSParseContext context, UHSNode currentNode, int startIndex ) {
		int index = startIndex;
		Matcher startMatcher = null;

		String tmp = context.getLine( index );  // Now it's interesting.
		index++;
		logger.warn( "Unknown hunk: {} (last parsed line: {})", tmp, context.getLastParsedLineNumber() );

		startMatcher = startPtn.matcher( context.getLine( index ) );
		index++;
		startMatcher.matches();
		int unknownId = Integer.parseInt( startMatcher.group( 1 ) );

		UHSNode newNode = new UHSNode( "Unknown" );
			newNode.setRawStringContent( "^UNKNOWN HUNK^" );
			newNode.setId( unknownId );
			currentNode.addChild( newNode );
			context.getRootNode().addLink( newNode );

		index += skipToEnd( context, unknownId, index );
		return index-startIndex;
	}

	/**
	 * Consumes lines until an END line is reached.
	 *
	 * @param context  the parse context
	 * @param id  an id to expect, as declared by the corresponding START line
	 * @param startIndex  the line number to start parsing from
	 * @return the number of lines consumed from the file
	 */
	public int skipToEnd( Proto4xUHSParseContext context, int id, int startIndex ) {
		int index = startIndex;
		Matcher endMatcher = null;
		String tmp = null;

		while ( context.hasLine( index ) ) {
			tmp = context.getLine( index );
			index++;
			endMatcher = endPtn.matcher( tmp );
			if ( endMatcher.matches() && endMatcher.group( 1 ).equals( id +"" ) ) {
				break;
			}
		}

		return index-startIndex;
	}


	private byte[] readBytesFromFile( File f ) throws IOException {
		byte[] result = null;
		InputStream is = null;
		try {
			is = new FileInputStream( f );
			long length = f.length();
			if ( length > Integer.MAX_VALUE ) return null;

			result = new byte[(int)length];
			int offset = 0;
			int numRead = 0;
			while ( offset < result.length && ( numRead=is.read( result, offset, result.length-offset ) ) >= 0 ) {
				offset += numRead;
			}
			if ( offset < result.length ) result = null;
			is.close();
		}
		finally {
			try {if ( is != null ) is.close();} catch ( IOException e ) {}
		}
		return result;
	}
}

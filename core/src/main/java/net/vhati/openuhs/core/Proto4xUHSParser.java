package net.vhati.openuhs.core;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import net.vhati.openuhs.core.DefaultUHSErrorHandler;
import net.vhati.openuhs.core.HotSpot;
import net.vhati.openuhs.core.UHSErrorHandler;
import net.vhati.openuhs.core.UHSErrorHandlerManager;
import net.vhati.openuhs.core.UHSHotSpotNode;
import net.vhati.openuhs.core.UHSNode;
import net.vhati.openuhs.core.UHSRootNode;


/**
 * Proto UHS 4.x file parser.
 * <br />"*.PUHS" files are generated by the UHS Source Editor v4.
 */
public class Proto4xUHSParser {
	/** Honor the actual UHS file structure for version 9x auxiliary nodes */
	public static final int AUX_NORMAL = 0;

	/** Drop version 9x auxiliary nodes */
	public static final int AUX_IGNORE = 1;

	/** Move version 9x auxiliary nodes to within the master subject node and make that the new root */
	public static final int AUX_NEST = 2;

	private int logLine = -1;
	private UHSErrorHandler errorHandler = null;


	/**
	 * Creates a Proto4xUHSParser.
	 *
	 * <p>A DefaultUHSErrorHandler(System.err) will be used.</p>
	 *
	 * @see #setErrorHandler(UHSErrorHandler)
	 */
	public Proto4xUHSParser() {
		this( new DefaultUHSErrorHandler( System.err ) );
	}

	/**
	 * Creates a Proto4xUHSParser and sets an error handler.
	 *
	 * @see #setErrorHandler(UHSErrorHandler)
	 */
	public Proto4xUHSParser( UHSErrorHandler eh ) {
		setErrorHandler( eh );
	}


	/**
	 * Sets the error handler to notify of exceptions.
	 *
	 * <p>This is a convenience for logging/muting.</p>
	 *
	 * @param eh the error handler, or null, for quiet parsing
	 */
	public void setErrorHandler( UHSErrorHandler eh ) {
		errorHandler = eh;
	}


	/**
	 * Reads a Proto4xUHS file into a List of text lines.
	 * Then calls an appropriate parser to construct a UHSRootNode and a tree of UHSNodes.
	 *
	 * <p>This is likely the only method you'll need.</p>
	 *
	 * @param f a file to read
	 * @param auxStyle option for 9x files AUX_NORMAL, AUX_IGNORE, or AUX_NEST
	 * @return the root of a tree of nodes representing the hint file
	 * @see #parse4xFormat(List, File, int)
	 */
	public UHSRootNode parseFile( File f, int auxStyle ) {
		if ( auxStyle != AUX_NORMAL && auxStyle != AUX_IGNORE && auxStyle != AUX_NEST ) return null;
		logLine = -1;

		List<String> uhsFileArray = new ArrayList<String>();

		try {
			RandomAccessFile inFile = new RandomAccessFile( f, "r" );

			logLine++;
			String tmp = inFile.readLine();
			if (!tmp.equals( "proto_UHS" )) {
				if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this, "Not a Proto4xUHS file!", logLine+1, null );
				return null;
			}
			uhsFileArray.add( tmp );

			byte tmpByte = -1;
			while ( (tmpByte = (byte)inFile.read()) != -1 ) {
				inFile.getChannel().position( inFile.getChannel().position()-1 );
				logLine++;
				tmp = inFile.readLine();
				uhsFileArray.add( tmp );
			}

			inFile.close();
		}
		catch ( FileNotFoundException e ) {
			if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this, "No file", logLine+1, e );
			return null;
		}
		catch ( IOException e ) {
			if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this, "Could not read file", logLine+1, e );
			return null;
		}


		UHSRootNode rootNode = parse4xFormat(uhsFileArray, f.getParentFile(), auxStyle);
		return rootNode;
	}


	/**
	 * Generates a tree of UHSNodes from Proto UHS 4.x.
	 *
	 * <p>These have not been seen in the wild.</p>
	 *
	 * <p>They're unencrypted and intended to be submitted by
	 * authors directly to the publisher. Oddly,
	 * UHS Source Editor 4.x (and presumably this format) doesn't
	 * fully support the features in the UHS 9x formats.</p>
	 *
	 * <p>Each node is given an arbitrary id on its START
	 * line, and it encloses everything until a matching END line.</p>
	 *
	 * <pre>@{code
	 * proto_UHS
	 * 0 proto_subject
	 * START *********** #
	 * title
	 * ...
	 * =
	 * ...
	 * END *********** #
	 * 0 proto_info
	 * START *********** #
	 * title File Information
	 * ...
	 * END *********** #
	 * }</pre>
	 *
	 * <p>The root node would normally contain up to two children.
	 * <ul>
	 * <li>A 'subject', containing all the subjects, hints, etc., that users care about.</li>
	 * <li>An 'info', mentioning the author, publisher, etc.</li>
	 * </ul></p>
	 *
	 * <p>For convenience, these auxiliary nodes can be treated differently.</p>
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @param auxStyle AUX_NORMAL (canon), AUX_IGNORE (omit), or AUX_NEST (move inside the master subject and make that the new root).
	 * @return the root of a tree of nodes
	 * @see #buildNodes(List, UHSRootNode, UHSNode, int, File)
	 */
	public UHSRootNode parse4xFormat( List<String> uhsFileArray, File workingDir, int auxStyle ) {
		if ( auxStyle != AUX_NORMAL && auxStyle != AUX_IGNORE && auxStyle != AUX_NEST ) return null;

		try {
			UHSRootNode rootNode = new UHSRootNode();
				rootNode.setContent( "root", UHSNode.STRING );

			int index = 1;
			index += buildNodes( uhsFileArray, rootNode, rootNode, index, workingDir );

			if ( auxStyle != AUX_IGNORE ) {
				if ( auxStyle == AUX_NEST ) {
					UHSNode tmpChildNode = rootNode.getChild( 0 );
					rootNode.setChildren( tmpChildNode.getChildren() );
					if ( tmpChildNode.getContentType() == UHSNode.STRING ) {
						rootNode.setContent( tmpChildNode.getContent(), UHSNode.STRING );
					} else {
						rootNode.setContent( "", UHSNode.STRING );
					}

					UHSNode blankNode = new UHSNode( "Blank" );
						blankNode.setContent( "--=File Info=--", UHSNode.STRING );
						rootNode.addChild( blankNode );
				}
				while (index < uhsFileArray.size()) {
					index += buildNodes( uhsFileArray, rootNode, rootNode, index, workingDir );
				}
			}
			return rootNode;
		}
		catch ( NumberFormatException e ) {
			if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this, "Could not parse nodes", logLine+1, e );
			return null;
		}
		catch ( ArrayIndexOutOfBoundsException e ) {
			if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this, "Could not parse nodes", logLine+1, e );
			return null;
		}
	}


	/**
	 * Recursively parses Proto UHS.
	 *
	 * <p>This recognizes various types of hints, and runs specialized methods to decode them.
	 * Unrecognized hints are harmlessly omitted.</p>
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param rootNode an existing root node
	 * @param currentNode an existing node to add children to
	 * @param startIndex the line number to start parsing from
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int buildNodes( List<String> uhsFileArray, UHSRootNode rootNode, UHSNode currentNode, int startIndex, File workingDir ) {
		int index = startIndex;

		String tmp = getLoggedString( uhsFileArray, index );
		if (tmp.matches( "[0-9]+ [A-Za-z_]+$" ) == true) {
			if (tmp.endsWith( "proto_subject" )) {
				index += parseSubjectNode( uhsFileArray, rootNode, currentNode, index, workingDir );
			}
			else if (tmp.endsWith( "proto_hint" )) {
				index += parseHintNode( uhsFileArray, rootNode, currentNode, index, workingDir );
			}
			else if (tmp.endsWith( "proto_text" )) {
				index += parseTextNode( uhsFileArray, rootNode, currentNode, index, workingDir );
			}
			else if (tmp.endsWith( "proto_comment" )) {
				index += parseCommentNode( uhsFileArray, rootNode, currentNode, index, workingDir );
			}
			else if (tmp.endsWith( "proto_credit" )) {
				index += parseCreditNode( uhsFileArray, rootNode, currentNode, index, workingDir );
			}
			else if (tmp.endsWith( "proto_link" )) {
				index += parseLinkNode( uhsFileArray, rootNode, currentNode, index, workingDir );
			}
			else if (tmp.endsWith( "proto_hyperpng" )) {
				index += parseHyperImgNode( uhsFileArray, rootNode, currentNode, index, workingDir );
			}
			else if (tmp.endsWith( "proto_info" )) {
				index += parseInfoNode( uhsFileArray, rootNode, currentNode, index, workingDir );
			}
			else {
				index += parseUnknownNode( uhsFileArray, rootNode, currentNode, index, workingDir );
			}
		}
		else {
			index++;
		}

		return index-startIndex;
	}

	/**
	 * Replaces UHS escaped characters in a hint.
	 * <br />Escapes have existed from version 88a onwards in most nodes' content and titles.
	 * <br />The # character is the main escape char and is written <b>##</b>.
	 *
	 * <ul><li><b>#</b> a '#' character.</li>
	 * <li><b>#a+</b>[AaEeIiOoUu][:'`^]<b>#a-</b> accent enclosed letter; :=diaeresis,'=acute,`=grave,^=circumflex.</li>
	 * <li><b>#a+</b>[Nn]~<b>#a-</b> accent enclosed letter with a tilde.</li>
	 * <li><b>#a+</b>ae<b>#a-</b> an ash character.</li>
	 * <li><b>#a+</b>TM<b>#a-</b> a trademark character.</li>
	 * <li><b>#w.</b> raw newlines are spaces.</li>
	 * <li><b>#w+</b> raw newlines are spaces (default).</li>
	 * <li><b>#w-</b> raw newlines are newlines.</li></ul>
	 *
	 * The following are left for display code to handle (e.g., UHSTextArea).
	 * <ul><li><b>#p+</b> proportional font (default).</li>
	 * <li><b>#p-</b> non-proportional font.</li></ul>
	 *
	 * This is displayed, but not a clickable hyperlink.
	 * <ul><li><b>#h+</b> through <b>#h-</b> is a hyperlink (http or email).</li></ul>
	 * <br />Illustrative UHS: <i>Portal: Achievements</i> (hyperlink)
	 *
	 * @param currentNode the node whose content needs replacing
	 */
	public void parseTextEscapes( UHSNode currentNode ) {
		if (currentNode.getContentType() != UHSNode.STRING) return;

		char[] linebreak = new char[] {'^','b','r','e','a','k','^'};
		char[] accentPrefix = new char[] {'#','a','+'};
		char[] accentSuffix = new char[] {'#','a','-'};
		char[] wspcA = new char[] {'#','w','+'};
		char[] wspcB = new char[] {'#','w','.'};
		char[] wnlin = new char[] {'#','w','-'};

		StringBuffer buf = new StringBuffer();
		char[] tmp = ((String)currentNode.getContent()).toCharArray();
		String breakStr = " ";
		char[] chunkA = null;
		char[] chunkB = null;
		boolean fudgedPos = false;

		for ( int c=0; c < tmp.length; c++ ) {
			if ( c+1 < tmp.length ) {
				if ( tmp[c] == '#' && tmp[c+1] == '#' ) {buf.append( '#' ); c+=1; continue;}
			}
			if ( tmp[c] == '#' ) {
				if ( c+7 < tmp.length ) {
					chunkA = new char[] {tmp[c],tmp[c+1],tmp[c+2]};
					chunkB = new char[] {tmp[c+5],tmp[c+6],tmp[c+7]};
					if (Arrays.equals( chunkA, accentPrefix ) && Arrays.equals( chunkB, accentSuffix )) {
						if ( tmp[c+4] == ':' ) {
							if ( tmp[c+3] == 'A' ) {buf.append( 'Ä' ); c+=7; continue;}
							if ( tmp[c+3] == 'E' ) {buf.append( 'Ë' ); c+=7; continue;}
							if ( tmp[c+3] == 'I' ) {buf.append( 'Ï' ); c+=7; continue;}
							if ( tmp[c+3] == 'O' ) {buf.append( 'Ö' ); c+=7; continue;}
							if ( tmp[c+3] == 'U' ) {buf.append( 'Ü' ); c+=7; continue;}
							if ( tmp[c+3] == 'a' ) {buf.append( 'ä' ); c+=7; continue;}
							if ( tmp[c+3] == 'e' ) {buf.append( 'ë' ); c+=7; continue;}
							if ( tmp[c+3] == 'i' ) {buf.append( 'ï' ); c+=7; continue;}
							if ( tmp[c+3] == 'o' ) {buf.append( 'ö' ); c+=7; continue;}
							if ( tmp[c+3] == 'u' ) {buf.append( 'ü' ); c+=7; continue;}
						}
						else if ( tmp[c+4] == '\'' ) {
							if ( tmp[c+3] == 'A' ) {buf.append( 'Á' ); c+=7; continue;}
							if ( tmp[c+3] == 'E' ) {buf.append( 'É' ); c+=7; continue;}
							if ( tmp[c+3] == 'I' ) {buf.append( 'Í' ); c+=7; continue;}
							if ( tmp[c+3] == 'O' ) {buf.append( 'Ó' ); c+=7; continue;}
							if ( tmp[c+3] == 'U' ) {buf.append( 'Ú' ); c+=7; continue;}
							if ( tmp[c+3] == 'a' ) {buf.append( 'á' ); c+=7; continue;}
							if ( tmp[c+3] == 'e' ) {buf.append( 'é' ); c+=7; continue;}
							if ( tmp[c+3] == 'i' ) {buf.append( 'í' ); c+=7; continue;}
							if ( tmp[c+3] == 'o' ) {buf.append( 'ó' ); c+=7; continue;}
							if ( tmp[c+3] == 'u' ) {buf.append( 'ú' ); c+=7; continue;}
						}
						else if ( tmp[c+4] == '`' ) {
							if ( tmp[c+3] == 'A' ) {buf.append( 'À' ); c+=7; continue;}
							if ( tmp[c+3] == 'E' ) {buf.append( 'È' ); c+=7; continue;}
							if ( tmp[c+3] == 'I' ) {buf.append( 'Ì' ); c+=7; continue;}
							if ( tmp[c+3] == 'O' ) {buf.append( 'Ò' ); c+=7; continue;}
							if ( tmp[c+3] == 'U' ) {buf.append( 'Ù' ); c+=7; continue;}
							if ( tmp[c+3] == 'a' ) {buf.append( 'à' ); c+=7; continue;}
							if ( tmp[c+3] == 'e' ) {buf.append( 'è' ); c+=7; continue;}
							if ( tmp[c+3] == 'i' ) {buf.append( 'ì' ); c+=7; continue;}
							if ( tmp[c+3] == 'o' ) {buf.append( 'ò' ); c+=7; continue;}
							if ( tmp[c+3] == 'u' ) {buf.append( 'ù' ); c+=7; continue;}
						}
						else if ( tmp[c+4] == '^' ) {
							if ( tmp[c+3] == 'A' ) {buf.append( 'Â' ); c+=7; continue;}
							if ( tmp[c+3] == 'E' ) {buf.append( 'Ê' ); c+=7; continue;}
							if ( tmp[c+3] == 'I' ) {buf.append( 'Î' ); c+=7; continue;}
							if ( tmp[c+3] == 'O' ) {buf.append( 'Ô' ); c+=7; continue;}
							if ( tmp[c+3] == 'U' ) {buf.append( 'Û' ); c+=7; continue;}
							if ( tmp[c+3] == 'a' ) {buf.append( 'â' ); c+=7; continue;}
							if ( tmp[c+3] == 'e' ) {buf.append( 'ê' ); c+=7; continue;}
							if ( tmp[c+3] == 'i' ) {buf.append( 'î' ); c+=7; continue;}
							if ( tmp[c+3] == 'o' ) {buf.append( 'ô' ); c+=7; continue;}
							if ( tmp[c+3] == 'u' ) {buf.append( 'û' ); c+=7; continue;}
						}
						else if ( tmp[c+4] == '~' ) {
							if ( tmp[c+3] == 'N' ) {buf.append( 'Ñ' ); c+=7; continue;}
							if ( tmp[c+3] == 'n' ) {buf.append( 'ñ' ); c+=7; continue;}
						}
						else if ( tmp[c+3] == 'a' && tmp[c+4] == 'e' ) {
							buf.append( 'æ' ); c+=7; continue;
						}
						else if ( tmp[c+3] == 'T' && tmp[c+4] == 'M' ) {
							buf.append( '™' ); c+=7; continue;
						}
						else {
							if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.INFO, this, "Unknown accent: "+ tmp[c+3] + tmp[c+4], logLine+1, null );
						}
					}
				}
				if ( c+2 < tmp.length ) {
					chunkA = new char[] {tmp[c],tmp[c+1],tmp[c+2]};
					if (Arrays.equals( chunkA, wspcA ) || Arrays.equals( chunkA, wspcB )) {breakStr = " "; c+=2; continue;}
					else if (Arrays.equals( chunkA, wnlin )) {breakStr = "\n"; c+=2; continue;}
				}
			}
			if ( c+6 < tmp.length ) {
				chunkA = new char[] {tmp[c],tmp[c+1],tmp[c+2],tmp[c+3],tmp[c+4],tmp[c+5],tmp[c+6]};
				if (Arrays.equals( chunkA, linebreak )) {buf.append( breakStr ); c += 6; continue;}
			}
			buf.append( tmp[c] );
		}

		currentNode.setContent(buf.toString(), UHSNode.STRING);
	}

	/**
	 * Generates a subject UHSNode and its contents.
	 *
	 * <pre>@{code
	 * 0 proto_subject
	 * START *********** #
	 * title
	 * =
	 * embedded hunk
	 * =
	 * embedded hunk
	 * END *********** #
	 * }</pre>
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param rootNode an existing root node
	 * @param currentNode an existing node to add children to
	 * @param startIndex the line number to start parsing from
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseSubjectNode( List<String> uhsFileArray, UHSRootNode rootNode, UHSNode currentNode, int startIndex, File workingDir ) {
		int index = startIndex;
		String[] tokens = null;
		String tmp = getLoggedString( uhsFileArray, index );  // Not interesting
		index++;

		tmp = getLoggedString( uhsFileArray, index );
		index++;
		tokens = tmp.split( " " );
		int subjectId = Integer.parseInt( tokens[2] );
		int restriction = UHSNode.RESTRICT_NONE;
		if ( tokens.length >= 4 ) {
			if ( tokens[3].equals( "Z" ) ) restriction = UHSNode.RESTRICT_NAG;
			if ( tokens[3].equals( "A" ) ) restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode subjectNode = new UHSNode( "Subject" );
			subjectNode.setContent( getLoggedString( uhsFileArray, index ), UHSNode.STRING );
			parseTextEscapes( subjectNode );
			subjectNode.setId( subjectId );
			subjectNode.setRestriction( restriction );
			currentNode.addChild( subjectNode );
			rootNode.addLink( subjectNode );
		index++;

		boolean done = false;
		while (!done && index < uhsFileArray.size()) {
			tmp = getLoggedString( uhsFileArray, index );
			index++;
			if ( tmp.matches( "END \\Q***********\\E "+ subjectId +"$" ) == true ) {
				done = true;
			}
			else if ( tmp.equals( "=" ) ) {
				index += buildNodes( uhsFileArray, rootNode, subjectNode, index, workingDir );
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates a normal hint UHSNode.
	 *
	 * <pre>@{code
	 * 0 proto_hint
	 * START *********** #
	 * Question
	 * hint (not encrypted)
	 * -
	 * hint (not encrypted)
	 * END *********** #
	 * }</pre>
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param rootNode an existing root node
	 * @param currentNode an existing node to add children to
	 * @param startIndex the line number to start parsing from
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseHintNode( List<String> uhsFileArray, UHSRootNode rootNode, UHSNode currentNode, int startIndex, File workingDir ) {
		String breakChar = "^break^";

		int index = startIndex;
		String[] tokens = null;
		String tmp = getLoggedString( uhsFileArray, index );  // Not interesting
		index++;

		tmp = getLoggedString( uhsFileArray, index );
		index++;
		tokens = tmp.split( " " );
		int hintId = Integer.parseInt( tokens[2] );
		int restriction = UHSNode.RESTRICT_NONE;
		if ( tokens.length >= 4 ) {
			if ( tokens[3].equals( "Z" ) ) restriction = UHSNode.RESTRICT_NAG;
			if ( tokens[3].equals( "A" ) ) restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode hintNode = new UHSNode( "Hint" );
			hintNode.setContent( getLoggedString( uhsFileArray, index ), UHSNode.STRING );
			parseTextEscapes( hintNode );
			hintNode.setId( hintId );
			hintNode.setRestriction( restriction );
			currentNode.addChild( hintNode );
			rootNode.addLink( hintNode );
		index++;

		StringBuffer tmpContent = new StringBuffer();
		UHSNode newNode = new UHSNode( "Hint" );

		boolean done = false;
		while (!done && index < uhsFileArray.size()) {
			tmp = getLoggedString( uhsFileArray, index );
			index++;
			if ( tmp.matches( "END \\Q***********\\E "+ hintId +"$" ) == true ) {
				done = true;
				if (tmpContent.length() > 0) {
					newNode.setContent(tmpContent.toString(), UHSNode.STRING);
					parseTextEscapes( newNode );
					hintNode.addChild( newNode );
				}
			}
			else if ( tmp.equals( "-" ) ) {
				if ( tmpContent.length() > 0 ) {
					newNode.setContent( tmpContent.toString(), UHSNode.STRING );
					parseTextEscapes( newNode );
					hintNode.addChild( newNode );
					newNode = new UHSNode( "Hint" );
					tmpContent.delete( 0, tmpContent.length() );
				}
			}
			else {
				if ( tmpContent.length() > 0 ) tmpContent.append( breakChar );

				if ( tmp.equals( " " ) ) tmpContent.append( "\n \n" );
				else tmpContent.append( tmp );
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates a text UHSNode.
	 *
	 * <pre>@{code
	 * 0 proto_text
	 * START *********** #
	 * title
	 * sentence
	 * sentence
	 * sentence
	 * END *********** #
	 * }</pre>
	 *
	 * <p>Rather than assuming "\n" everywhere, in-file linebreaks
	 * are preserved (for context-sensitive escaping later).
	 * Markup will be inserted to begin with that as the default.</p>
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param rootNode an existing root node
	 * @param currentNode an existing node to add children to
	 * @param startIndex the line number to start parsing from
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseTextNode( List<String> uhsFileArray, UHSRootNode rootNode, UHSNode currentNode, int startIndex, File workingDir ) {
		String breakChar = "^break^";

		int index = startIndex;
		String[] tokens = null;
		String tmp = getLoggedString( uhsFileArray, index );  // Not interesting
		index++;

		tmp = getLoggedString( uhsFileArray, index );
		index++;
		tokens = tmp.split( " " );
		int textId = Integer.parseInt( tokens[2] );
		int restriction = UHSNode.RESTRICT_NONE;
		if ( tokens.length >= 4 ) {
			if ( tokens[3].equals( "Z" ) ) restriction = UHSNode.RESTRICT_NAG;
			if ( tokens[3].equals( "A" ) ) restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode textNode = new UHSNode( "Text" );
			textNode.setContent( getLoggedString( uhsFileArray, index ), UHSNode.STRING );
			parseTextEscapes( textNode );
			textNode.setId( textId );
			textNode.setRestriction( restriction );
			currentNode.addChild( textNode );
			rootNode.addLink( textNode );
		index++;

		StringBuffer tmpContent = new StringBuffer();
		UHSNode newNode = new UHSNode( "TextData" );

		boolean done = false;
		while ( !done && index < uhsFileArray.size() ) {
			tmp = getLoggedString( uhsFileArray, index );
			index++;
			if ( tmp.matches( "END \\Q***********\\E "+ textId +"$" ) == true ) {
				done = true;
				if ( tmpContent.length() > 0 ) {
					if ( tmpContent.length() < 3 || !tmpContent.substring( 0, 3 ).startsWith( "#w-" ) ) {
						tmpContent.insert( 0, "#w-" );  // Text nodes default to honoring newlines
					}
					newNode.setContent( tmpContent.toString(), UHSNode.STRING );
					parseTextEscapes( newNode );
					textNode.addChild( newNode );
				}
			}
			else {
				if ( tmpContent.length() > 0 ) tmpContent.append( breakChar );

				if ( tmp.equals( " " ) ) tmpContent.append( "\n \n" );
				else tmpContent.append( tmp );
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates a comment UHSNode.
	 *
	 * <pre>@{code
	 * 0 proto_comment
	 * START *********** #
	 * title
	 * sentence
	 * sentence
	 * sentence
	 * END *********** #
	 * }</pre>
	 *
	 * <p>Rather than assuming " " everywhere, in-file linebreaks
	 * are preserved (for context-sensitive escaping later).
	 * Markup will be inserted to begin with that as the default.</p>
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param rootNode an existing root node
	 * @param currentNode an existing node to add children to
	 * @param startIndex the line number to start parsing from
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseCommentNode( List<String> uhsFileArray, UHSRootNode rootNode, UHSNode currentNode, int startIndex, File workingDir ) {
		String breakChar = "^break^";

		int index = startIndex;
		String[] tokens = null;
		String tmp = getLoggedString( uhsFileArray, index );  // Not interesting
		index++;

		tmp = getLoggedString( uhsFileArray, index );
		index++;
		tokens = tmp.split( " " );
		int commentId = Integer.parseInt( tokens[2] );
		int restriction = UHSNode.RESTRICT_NONE;
		if ( tokens.length >= 4 ) {
			if ( tokens[3].equals( "Z" ) ) restriction = UHSNode.RESTRICT_NAG;
			if ( tokens[3].equals( "A" ) ) restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode commentNode = new UHSNode( "Comment" );
			commentNode.setContent( getLoggedString( uhsFileArray, index ), UHSNode.STRING );
			parseTextEscapes( commentNode );
			commentNode.setId( commentId );
			commentNode.setRestriction( restriction );
			currentNode.addChild( commentNode );
			rootNode.addLink( commentNode );
		index++;

		StringBuffer tmpContent = new StringBuffer();
		UHSNode newNode = new UHSNode( "CommentData" );

		boolean done = false;
		while ( !done && index < uhsFileArray.size() ) {
			tmp = getLoggedString( uhsFileArray, index );
			index++;
			if ( tmp.matches( "END \\Q***********\\E "+ commentId +"$" ) == true ) {
				done = true;
				if ( tmpContent.length() > 0 ) {
					newNode.setContent( tmpContent.toString(), UHSNode.STRING );
					parseTextEscapes( newNode );
					commentNode.addChild( newNode );
				}
			}
			else {
				if ( tmpContent.length() > 0 ) tmpContent.append( breakChar );

				if ( tmp.equals( " " ) ) tmpContent.append( "\n \n" );
				else tmpContent.append( tmp );
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates a credit UHSNode.
	 *
	 * <pre>@{code
	 * 0 proto_credit
	 * START *********** #
	 * title
	 * sentence
	 * sentence
	 * sentence
	 * END *********** #
	 * }</pre>
	 *
	 * <p>Rather than assuming " " everywhere, in-file linebreaks
	 * are preserved (for context-sensitive escaping later).
	 * Markup will be inserted to begin with that as the default.</p>
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param rootNode an existing root node
	 * @param currentNode an existing node to add children to
	 * @param startIndex the line number to start parsing from
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseCreditNode( List<String> uhsFileArray, UHSRootNode rootNode, UHSNode currentNode, int startIndex, File workingDir ) {
		String breakChar = "^break^";

		int index = startIndex;
		String[] tokens = null;
		String tmp = getLoggedString( uhsFileArray, index );  // Not interesting
		index++;

		tmp = getLoggedString( uhsFileArray, index );
		index++;
		tokens = tmp.split( " " );
		int creditId = Integer.parseInt( tokens[2] );
		int restriction = UHSNode.RESTRICT_NONE;
		if ( tokens.length >= 4 ) {
			if ( tokens[3].equals( "Z" ) ) restriction = UHSNode.RESTRICT_NAG;
			if ( tokens[3].equals( "A" ) ) restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode creditNode = new UHSNode( "Credit" );
			creditNode.setContent( getLoggedString( uhsFileArray, index ), UHSNode.STRING );
			parseTextEscapes( creditNode );
			creditNode.setId( creditId );
			creditNode.setRestriction( restriction );
			currentNode.addChild( creditNode );
			rootNode.addLink( creditNode );
		index++;

		StringBuffer tmpContent = new StringBuffer();
		UHSNode newNode = new UHSNode( "CreditData" );

		boolean done = false;
		while ( !done && index < uhsFileArray.size() ) {
			tmp = getLoggedString( uhsFileArray, index );
			index++;
			if ( tmp.matches( "END \\Q***********\\E "+ creditId +"$" ) == true ) {
				done = true;
				if ( tmpContent.length() > 0 ) {
					newNode.setContent( tmpContent.toString(), UHSNode.STRING );
					parseTextEscapes( newNode );
					creditNode.addChild( newNode );
				}
			}
			else {
				if ( tmpContent.length() > 0 ) tmpContent.append( breakChar );

				if ( tmp.equals(" ") ) tmpContent.append( "\n \n" );
				else tmpContent.append( tmp );
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates a link UHSNode.
	 *
	 * <p>Nodes like this that have link targets behave like conventional hyperlinks instead of containing child nodes.</p>
	 *
	 * <pre>@{code
	 * 0 proto_link
	 * START *********** #
	 * title
	 * index
	 * }</pre>
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param rootNode an existing root node
	 * @param currentNode an existing node to add children to
	 * @param startIndex the line number to start parsing from
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseLinkNode( List<String> uhsFileArray, UHSRootNode rootNode, UHSNode currentNode, int startIndex, File workingDir ) {
		int index = startIndex;
		String[] tokens = null;
		String tmp = getLoggedString( uhsFileArray, index );  // Not interesting
		index++;

		tmp = getLoggedString( uhsFileArray, index );
		index++;
		tokens = tmp.split( " " );
		int linkId = Integer.parseInt( tokens[2] );
		int restriction = UHSNode.RESTRICT_NONE;
		if ( tokens.length >= 4 ) {
			if ( tokens[3].equals( "Z" ) ) restriction = UHSNode.RESTRICT_NAG;
			if ( tokens[3].equals( "A" ) ) restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode linkNode = new UHSNode( "Link" );
			linkNode.setContent( getLoggedString( uhsFileArray, index ), UHSNode.STRING );
			parseTextEscapes( linkNode );
			linkNode.setId( linkId );
			linkNode.setRestriction( restriction );
			currentNode.addChild( linkNode );
			rootNode.addLink( linkNode );
		index++;

		int targetIndex = Integer.parseInt( getLoggedString( uhsFileArray, index ) );
			linkNode.setLinkTarget( targetIndex );
		index++;

		boolean done = false;
		while ( !done && index < uhsFileArray.size() ) {
			tmp = getLoggedString( uhsFileArray, index );
			index++;
			if ( tmp.matches( "END \\Q***********\\E "+ linkId +"$" ) == true ) {
				done = true;
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates an image-filled UHSNode.
	 *
	 * <p>The UHS format allows for regions that trigger links or reveal overlaid subimages.</p>
	 *
	 * <p>UHSHotSpotNode was written to handle regions.</p>
	 *
	 * <pre>@{code
	 * 0 proto_hyperpng
	 * START *********** #
	 * title
	 * file-path 0 0
	 * --not-a-gap--
	 * x y x+w y+h
	 * 0 proto_link
	 * START *********** #
	 * title
	 * index
	 * END *********** #
	 * --not-a-gap--
	 * x y x+w y+h
	 * 0 proto_link
	 * START *********** #
	 * title
	 * index
	 * END *********** #
	 * --not-a-gap--
	 * x y x+w y+h
	 * 0 proto_overlay
	 * START *********** #
	 * title
	 * file-path 0 0 x y
	 * END *********** #
	 * --not-a-gap--
	 * x y x+w y+h
	 * 0 proto_overlay
	 * START *********** #
	 * title
	 * file-path 0 0 x y
	 * END *********** #
	 * }</pre>
	 *
	 * <p>Paths point to png images (spaces are replaced with "?").</p>
	 * <p>There is no comparable gifa structure.</p>
	 *
	 * <p>To create this in the UHS Source Editor...
	 * <ul>
	 * <li>Add_Menu-HyperPNG, pick a title and image.</li>
	 * <li> - Add_Menu-Link, pick a target.</li>
	 * <li> - - Highlight the link in the list, then drag a region on the image.</li>
	 * <li> - Add_Menu-Overlay, pick a title and image.</li>
	 * <li> - - Click somewhere in the overlay popup's image to set the top-left.</li>
	 * <li> - - Close the overlay's popup.</li>
	 * <li> - - Highlight the overlay in the list, then drag a region on the image.</li>
	 * </ul></p>
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param rootNode an existing root node
	 * @param currentNode an existing node to add children to
	 * @param startIndex the line number to start parsing from
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @return the number of lines consumed from the file in parsing children
	 * @see net.vhati.openuhs.core.UHSHotSpotNode
	 */
	public int parseHyperImgNode( List<String> uhsFileArray, UHSRootNode rootNode, UHSNode currentNode, int startIndex, File workingDir ) {
		int index = startIndex;
		String[] tokens = null;
		String imgPath = null;
		File imgFile = null;
		byte[] tmpBytes = null;
		int x = 0;
		int y = 0;
		UHSHotSpotNode hotspotNode = new UHSHotSpotNode( "HotSpot" );

		String tmp = getLoggedString( uhsFileArray, index );  // Not interesting
		index++;

		tmp = getLoggedString( uhsFileArray, index );
		index++;
		tokens = tmp.split( " " );
		int hyperId = Integer.parseInt( tokens[2] );
		int restriction = UHSNode.RESTRICT_NONE;
		if ( tokens.length >= 4 ) {
			if ( tokens[3].equals( "Z" ) ) restriction = UHSNode.RESTRICT_NAG;
			if ( tokens[3].equals( "A" ) ) restriction = UHSNode.RESTRICT_REGONLY;
		}

		UHSNode imgNode = new UHSNode( "Hyperpng" );
		String title = getLoggedString( uhsFileArray, index );
		index++;

		tokens = (getLoggedString( uhsFileArray, index )).split( " " );
		index++;
		if ( tokens.length != 3 ) {
			boolean done = false;
			while (!done && index < uhsFileArray.size()) {
				tmp = getLoggedString( uhsFileArray, index );
				index++;
				if ( tmp.matches( "END \\Q***********\\E "+ hyperId +"$" ) == true ) {
					done = true;
				}
			}
			return index-startIndex;
		}
		imgPath = tokens[0].replaceAll( "[?]", " " ).replace( '\\', '/' );
		imgFile = null;
		if ( imgPath.startsWith( "." ) ) {
			imgFile = new File( workingDir, imgPath );
		} else {
			imgFile = new File( imgPath );
		}
		// Skip dummy zeroes
		tmpBytes = readBytesFromFile( imgFile );
		if ( tmpBytes == null ) {
			if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this, "Could not get bytes for Hyperpng hunk", logLine+1, null );
		}
		imgNode.setContent( tmpBytes, UHSNode.IMAGE );

		// This if-else would make regionless hyperimgs standalone and unnested
		//if ( getLoggedString( uhsFileArray, index ).matches( "END \\Q***********\\E "+ hyperId +"$" ) == false ) {
			hotspotNode.addChild( imgNode );

			hotspotNode.setContent( title, UHSNode.STRING );
			hotspotNode.setId( hyperId );
			hotspotNode.setRestriction( restriction );
			currentNode.addChild( hotspotNode );
			rootNode.addLink( hotspotNode );
		//} else {
		//  imgNode.setId( hyperId );
		//  currentNode.addChild( imgNode );
		//  rootNode.addLink( imgNode );
		//}


		boolean done = false;
		while ( !done && index < uhsFileArray.size() ) {
			tmp = getLoggedString( uhsFileArray, index );
			index++;
			if ( tmp.matches( "END \\Q***********\\E "+ hyperId +"$" ) == true ) {
				done = true;
			}
			else if ( tmp.matches( "[0-9]+ [0-9]+ [0-9]+ [0-9]+ *$" ) ) {
				tokens = tmp.trim().split( " " );
				int zoneX1 = Integer.parseInt( tokens[0] )-1;
				int zoneY1 = Integer.parseInt( tokens[1] )-1;
				int zoneX2 = Integer.parseInt( tokens[2] )-1;
				int zoneY2 = Integer.parseInt( tokens[3] )-1;

				tmp = getLoggedString( uhsFileArray, index );
				index++;
				if ( tmp.matches( "[0-9]+ [A-Za-z_]+$" ) == true ) {
					if ( tmp.endsWith( "proto_overlay" ) ) {
						index++;  // This should skip the overlay's START line
						index++;  // This should skip the overlay's title line
						tmp = getLoggedString( uhsFileArray, index );
						index++;
						tokens = tmp.trim().split( " " );
						if ( tokens.length == 5 && zoneX1 < zoneX2 && zoneY1 < zoneY2 ) {
							imgPath = tokens[0].replaceAll( "[?]", " " ).replace( '\\', '/' );
							imgFile = null;
							if ( imgPath.startsWith( "." ) ) {
								imgFile = new File( workingDir, imgPath );
							} else {
								imgFile = new File( imgPath );
							}
							// Skip dummy zeroes
							int posX = Integer.parseInt( tokens[3] )-1;
							int posY = Integer.parseInt( tokens[4] )-1;

							UHSNode newNode = new UHSNode( "Overlay" );
							tmpBytes = readBytesFromFile( imgFile );
							if ( tmpBytes == null ) {
								if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this, "Could not get bytes for Hyperpng hunk", logLine+1, null );
							}
							newNode.setContent( tmpBytes, UHSNode.IMAGE );
							hotspotNode.addChild( newNode );
							hotspotNode.setSpot( newNode, new HotSpot( zoneX1, zoneY1, zoneX2-zoneX1, zoneY2-zoneY1, posX, posY ) );
						} else {
							if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this, "Invalid coords for hyper-overlay hunk", logLine+1, null );
						}
						index++;  // This should skip the overlay's END line
					}
					else if (tmp.endsWith( "proto_link" )) {
						index++;  // This should skip the link's START line
						title = getLoggedString( uhsFileArray, index );
						index++;
						int targetIndex = Integer.parseInt( getLoggedString( uhsFileArray, index ) );
						index++;
						if ( zoneX1 < zoneX2 && zoneY1 < zoneY2 ) {
							UHSNode newNode = new UHSNode( "Link" );
								newNode.setContent( title, UHSNode.STRING );
								parseTextEscapes( newNode );
								hotspotNode.addChild( newNode );
								hotspotNode.setSpot( newNode, new HotSpot( zoneX1, zoneY1, zoneX2-zoneX1, zoneY2-zoneY1, -1, -1 ) );
								newNode.setLinkTarget( targetIndex );
						} else {
							if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this, "Invalid coords/target for hyper-link hunk", logLine+1, null );
						}
						index++;  // This should skip the link's END line
					}
				}
			}
		}

		return index-startIndex;
	}

	/**
	 * Generates an info UHSNode.
	 *
	 * <pre>@{code
	 * 0 proto_info
	 * START *********** #
	 * title
	 * author=name
	 * publisher=name
	 * author-note=sentence
	 * game-note=sentence
	 * copyright=sentence
	 * comments=sentence
	 * END *********** #
	 * }</pre>
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param rootNode an existing root node
	 * @param currentNode an existing node to add children to
	 * @param startIndex the line number to start parsing from
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseInfoNode( List<String> uhsFileArray, UHSRootNode rootNode, UHSNode currentNode, int startIndex, File workingDir ) {
		String breakChar = " ";

		int index = startIndex;
		String[] tokens = null;
		String tmp = getLoggedString( uhsFileArray, index );  // Not interesting
		index++;

		tmp = getLoggedString( uhsFileArray, index );
		index++;
		tokens = tmp.split( " " );
		int infoId = Integer.parseInt( tokens[2] );
		int restriction = UHSNode.RESTRICT_NONE;
		// Don't bother with restriction

		UHSNode infoNode = new UHSNode( "Info" );
			infoNode.setContent( getLoggedString( uhsFileArray, index ), UHSNode.STRING );
			parseTextEscapes( infoNode );
			infoNode.setId( infoId );
			currentNode.addChild( infoNode );
			rootNode.addLink( infoNode );
		index++;

		StringBuffer authorBuf = new StringBuffer();
		StringBuffer publisherBuf = new StringBuffer();
		StringBuffer authorNoteBuf = new StringBuffer();
		StringBuffer gameNoteBuf = new StringBuffer();
		StringBuffer copyrightBuf = new StringBuffer();
		StringBuffer noticeBuf = new StringBuffer();  // "comments="

		StringBuffer unknownBuf = new StringBuffer();
		StringBuffer[] buffers = new StringBuffer[] {authorBuf, publisherBuf, authorNoteBuf, gameNoteBuf, copyrightBuf, noticeBuf, unknownBuf};

		StringBuffer tmpContent = new StringBuffer();
		StringBuffer currentBuffer = null;
		UHSNode newNode = new UHSNode( "InfoData" );

		boolean done = false;
		while ( !done && index < uhsFileArray.size() ) {
			tmp = getLoggedString( uhsFileArray, index );
			index++;

			if ( tmp.startsWith( "copyright" ) || tmp.startsWith( "author-note" ) || tmp.startsWith( "game-note" ) || tmp.startsWith( "comments" ) ) breakChar = " ";
			else breakChar = "\n";  // The official editor doesn't seem capable of linebreaks

			if ( tmp.matches( "END \\Q***********\\E "+ infoId +"$" ) == true ) {
				done = true;
				for ( int i=0; i < buffers.length; i++ ) {
					if ( buffers[i].length() == 0 ) continue;
					if ( tmpContent.length() > 0 ) {
						tmpContent.append( "\n" );
						if ( buffers[i] == authorNoteBuf ||
								buffers[i] == gameNoteBuf ||
								buffers[i] == copyrightBuf ||
								buffers[i] == noticeBuf ) {
							tmpContent.append( "\n" );
						}
					}
					tmpContent.append( buffers[i] );
				}

				newNode.setContent( tmpContent.toString(), UHSNode.STRING );
				parseTextEscapes( newNode );
				infoNode.addChild( newNode );
			}
			else if ( tmp.startsWith( "author=" ) ) {
				currentBuffer = authorBuf;
				//tmp = tmp.substring( 7 );
			}
			else if ( tmp.startsWith( "publisher=" ) ) {
				currentBuffer = publisherBuf;
				//tmp = tmp.substring( 10 );
			}
			else if ( tmp.startsWith( "author-note=" ) ) {
				currentBuffer = authorNoteBuf;
				if ( currentBuffer.length() == 0 ) {currentBuffer.append( "author-note=" ); breakChar = "";}
				tmp = tmp.substring( 12 );
			}
			else if ( tmp.startsWith( "game-note=" ) ) {
				currentBuffer = gameNoteBuf;
				if ( currentBuffer.length() == 0 ) {currentBuffer.append( "game-note=" ); breakChar = "";}
				tmp = tmp.substring( 10 );
			}
			else if ( tmp.startsWith( "copyright=" ) ) {
				currentBuffer = copyrightBuf;
				if ( currentBuffer.length() == 0 ) {currentBuffer.append( "copyright=" ); breakChar = "";}
				tmp = tmp.substring( 10 );
			}
			else if ( tmp.startsWith("comments=") ) {
				currentBuffer = noticeBuf;
				tmp = tmp.substring( 9 );
			}
			else {
				currentBuffer = unknownBuf;
				if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this, "Unknown Info hunk line: "+ tmp, logLine+1, null );
			}

			if ( currentBuffer.length() > 0 ) currentBuffer.append( breakChar );
			currentBuffer.append( tmp );
		}

		return index-startIndex;
	}

	/**
	 * Generates a stand-in UHSNode for an unknown hunk.
	 *
	 * @param uhsFileArray a List of all available lines in the file
	 * @param rootNode an existing root node
	 * @param currentNode an existing node to add children to
	 * @param startIndex the line number to start parsing from
	 * @param workingDir the dir containing the hint file, for finding relative paths
	 * @return the number of lines consumed from the file in parsing children
	 */
	public int parseUnknownNode( List<String> uhsFileArray, UHSRootNode rootNode, UHSNode currentNode, int startIndex, File workingDir ) {
		int index = startIndex;
		String tmp = getLoggedString( uhsFileArray, index );
		index++;

		if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.INFO, this, "Unknown Hunk: "+ tmp, logLine+1, null );

		tmp = getLoggedString( uhsFileArray, index );
		index++;
		int unknownId = Integer.parseInt( tmp.substring( tmp.lastIndexOf( " " )+1 ) );

		UHSNode newNode = new UHSNode( "Unknown" );
			newNode.setContent( "^UNKNOWN HUNK^", UHSNode.STRING );
			newNode.setId( unknownId );
			currentNode.addChild( newNode );
			rootNode.addLink( newNode );

		boolean done = false;
		while ( !done && index < uhsFileArray.size() ) {
			tmp = getLoggedString( uhsFileArray, index );
			index++;
			if ( tmp.matches( "END \\Q***********\\E "+ unknownId +"$" ) == true ) {
				done = true;
			}
		}

		return index-startIndex;
	}


	private byte[] readBytesFromFile( File f ) {
		byte[] result = null;
		InputStream is = null;
		try {
			is = new FileInputStream( f );
			long length = f.length();
			if ( length > Integer.MAX_VALUE ) return null;

			result = new byte[(int)length];
			int offset = 0;
			int numRead = 0;
			while ( offset < result.length && ( numRead=is.read( result, offset, result.length-offset ) ) >= 0 ) {
				offset += numRead;
			}
			if ( offset < result.length ) result = null;
			is.close();
		}
		catch ( IOException e ) {
			if ( errorHandler != null ) errorHandler.log( UHSErrorHandler.ERROR, this,  "Could not read bytes from file: "+ f.getAbsolutePath(), logLine+1, null );
		}
		finally {
			try {if ( is != null ) is.close();} catch ( IOException e ) {}
		}
		return result;
	}


	private String getLoggedString( List<String> uhsFileArray, int n ) {
		logLine = n;
		return uhsFileArray.get( n );
	}
}
